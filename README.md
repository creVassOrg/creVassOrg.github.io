# What if multi-modal LLM artificial intelligence actually made things radically simpler?

EVENTUALLY, the [DRAIN.tips inference engine](https://github.com/DRAINtips) might make it all ***seem*** simple for the user ... while the DRAIN.tips LLM [transformer engine](https://github.com/creVassOrg/TransformerEngine) pre-digests massive amounts of the multi-modal data into something relatively simple for the inference engine to chew on.

But FIRST, it's about data wrangling and speed of communication between the user with an AI phone and the heavy machinery in the cloud ... to have a clue about what we are trying to build there, we'll have to ingest a LOT of repositories covering the finer points of multi-modal data wrangling such as the [LAVIS](https://github.com/creVassOrg/LAVIS) Python library for Language-Vision Intelligence ... the [docarray](https://github.com/creVassOrg/docarray) Python library crafted for the representation, transmission, storage, and retrieval of multimodal data and the [jina AI pipeline](https://github.com/creVassOrg/jina) for multimodal data communications via gRPC, HTTP and WebSockets ... the [LiveKit Server](https://github.com/creVassOrg/livekit) scalable, real-time video/data for multi-user conferencing based on the [Pion WebRTC API, written in Go](https://github.com/pion/webrtc) ... [Pydantic](https://github.com/creVassOrg/pydantic) data validation using Python type hints based on the [FastAPI](https://github.com/creVassOrg/fastapi) web framework

*Optimizing the neurosphere of work involves improving the DEEP flow of the play of a riveting game.* **SIMPLIFICATION of impossibly tough problems is ALL in the mind.** Better theories come from taking away the noise, eg ***E = mc<sup>2</sup>***

Developers have to ditch the cleverness that clogging their codebases ... but doing this requires admitting that code does not flow ... and THE REASON for that lack of flow is that *many developers try to stuff too much long hair featurebloat* ... 

# ... down the ol' ***GITPIPE***.

### Wait! WTF is a ***GitPipe***?

Let's re-read [Git Branching](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell) with some additional focus on [Git Internals - Plumbing and Porcelain](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain) ... approach this whole thing from a different perspective, with some serious thought given to how we might reduce just shoving things down the gitpipe just because the thing will swallow anything we commit.

A ***gitpipe*** is nothing but a likely to be thrown away git ***branch*** that has been created for the sole purpose of staging a soft, mushy, still WORK-IN-PROCESS-EY ***commit*** ... we might want several ***gitpipes*** to hold several different ideas ... but the GOAL of the final master commit is a radically SIMPLER, SMALLER, TIGHTER ***commit*** that make future code more maintainable, more likely to flow. ALWAYS BE SIMPLIFYING the alternative ***gitpipes*** with an eye to selecting the very simplest, tightest, most solid code ... you don't want lots of hair or stringey fur in your code, because *you will get enough of that stuff without trying*.

### DeepGit is for unclogging clogged ***gitpipes***

HOW does the subconscious process things into a simpler concepts that the conscious mind insists upon making more complex ... what if we could use ML/AI to subconsciously simplify the code we write? 
